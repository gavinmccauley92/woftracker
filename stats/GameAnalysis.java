package woftracker.stats;

import woftracker.*;
import woftracker.record.*;
import woftracker.util.*;
import woftracker.puzzle.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import java.time.*;
import java.time.format.*;
import java.math.*;
import java.io.*;
import java.nio.file.*;
import java.nio.charset.Charset;
import javax.swing.JOptionPane;
import java.lang.reflect.*;

import static woftracker.util.FormatFactory.*;

public class GameAnalysis implements Serializable, Comparable<GameAnalysis>, StatEnums {
	private static final long serialVersionUID = 1L;	//version number.
	
	private StringBuilder report;
	
	private String gameFileName, title;
	private LocalDate showDate;
	
	private int showNumber, seasonNumber;
	
	//only set to true at the end of reporting, i.e. the end of analyzing. All the analyze methods will throw an exception if this is true, "disabling" them.
	private boolean isDone = false;
	
	private transient Round currentRound;
	private transient Deque<Round> unusedRounds;
	
	static final String DISCLAIMER = "\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n" +
		"*Key for one-var stats: n = size of data  |  min, q1, median, q3, max  |  mean +/- stdev  |  mode(s)\n\n" +
		"The accuracy of these statistics is ultimately up to the client of this program to input everything correctly. If there is a major error, contact Wayoshi with the exact correction(s), and he can fix it.\n\n" +
		"We must use what WOF shows us as the official statistics. Due to editing, this may not be perfect: Wheel edits like spinning are common (especially on final spins), so if min/max spin strengths are huge outliers, this is probably why. Editing more major than this is very rare, however.\n\n" +
		"This text file was generated by the WOF Tracker Java Program, created by Wayoshi.\n\n",
	
		LINE = "\n\n-------------------------------\n\n"
	;
	
	/* link variable names to their actual contents for AnalysisPanel */
	
	static final Vector<String> STAT_NAMES = new Vector<>();	//particular order wanted, keySet() of Map would only potentially have a sorted order if TreeMap
	public static final Map<String, Field> STAT_MAP;
	static {
		Map<String, Field> sm = new LinkedHashMap<>();	//insertion order - maintain ordering of variables
		for(Field f : GameAnalysis.class.getDeclaredFields()) {
			int modifiers = f.getModifiers();
			if(!Modifier.isPrivate(modifiers) && !Modifier.isStatic(modifiers)) {	//all transient variables are private anyways
				String s = f.getName();
				s = s.substring(s.lastIndexOf('.') + 1);
				STAT_NAMES.add(s);
				sm.put(s, f);
			} else if(f.getType() == StringBuilder.class) {	//exception
				STAT_NAMES.add(0, "report");
				sm.put("report", f);
			}
		}
		STAT_MAP = Collections.unmodifiableMap(sm);
	}
	
	// allow public access to package-private variables (e.g. analysis statistics).
	public Object getStat(Field gaField) {
		if(gaField.getModifiers() != 0)	//package-private instance variables are stats
			return null;
		try {
			return gaField.get(this);
		} catch(IllegalAccessException e) {
			return null;
		}
	}
	
	/* the following is useful enums for GameAnalysis (and should be outside of this class but I realized this too late) */
	
	public static enum Round { T1, T2, R1, R2, R3, T3, R4, R5, R6, R7, TT, BR };

	//this enum has no relation in its ordinals to each other, yet overriding ordinal() and disabling the function probably ruins EnumSet, which will be used in MultiGameAnalysis.
	public static enum PrizeEvent {
		Not_picked_up, Picked_up, Was_bankrupt, Retired_from_risk, Bankrupted, Retired, Claimed, Used, Abandoned, Completed, Bankrupted_after_claimed, Lost_maingame, Went_to_BR;	//all unique
		//all				all		< --- Mysterys only ----- >		 <--- not WC ---> 	all	  	WC only		< - 1/2 only - >		< ----------- WC/MDW ------------------- >
		
		public String toString() {
			return name().replace('_', ' ');
		}
	};

	public static enum FreePlayEvent {
		Consonant, Vowel, Solve_attempt, Buzzed;
		
		public String toString() {
			return name().replace('_', ' ');
		}
	}

	/* end enums. */
	
	//see pre-method for each analyze method for the fields that are declared here.
	public GameAnalysis() {
		report = new StringBuilder(6250);
		
		prizeResults = new EnumMap<>(Wedge.class);
		
		spinLocations = new BarChartPartition<>(MAINGAME, ALL_WEDGES);
		leftRightMDWHits = new BarChart<>(EnumSet.of(Round.R1, Round.R2, Round.R3));
		spinStrengths = new EnumMap<>(Player.class);
			for(Player p : ALL_PLAYERS) spinStrengths.put(p, new LinkedList<Short>());
		spinStrengthStats = new EnumMap<>(Player.class);
		freePlayActions = new BarChart<>(ALL_FREEPLAY_EVENTS);
		lachTrash = new BarChartPartition<>(MAINGAME, ALL_PLAYERS);
		bigMoneyFreq = new EnumMap<>(Wedge.class);
			for(Wedge w : BIG_MONEY) bigMoneyFreq.put(w, new LinkedList<Byte>());
		wasteFreq = new EnumMap<>(Wedge.class);
		expressRides = new LinkedList<>();
		
		winnings = new BarChart<>(ALL_ROUNDS);
		missolves = new BarChart<>(ALL_ROUNDS);
		lostTurns = new BarChart<>(MAINGAME);
		lostBanks = new BarChartPartition<>(MAINGAME, ALL_PLAYERS);
		puzzleDissections = new BarChartPartition<>(ALL_ROUNDS, ALL_LETTERS);
		puzzleDetails = new EnumMap<>(Round.class);
		roundWinners = new EnumMap<>(Round.class);
		perfectRounds = EnumSet.noneOf(Round.class);
		allVowelsBought = EnumSet.noneOf(Round.class);
		allConsonantsCalled = EnumSet.noneOf(Round.class);
		highestMultLetters = new EnumMap<>(Round.class);
		
		mainBuzzes = new BarChart<>(MAINGAME);
		tossUpBlanks = new BarChart<>(TOSSUPS);
		
		pp = Round.R3;	//maybe sometime they will go back to a varying PP.
		
		finalMainWinnings = new BarChart<>(ALL_PLAYERS);
		roundCat = new EnumMap<>(Round.class);
		
		calledByPlayer = new BarChartPartition<>(ALL_PLAYERS, ALL_LETTERS);	//implicitly, maingame only
		calledByRound = new EnumMap<>(Round.class);
			for(Round r : ALL_ROUNDS_EXCEPT_TOSS) calledByRound.put(r, new LinkedList<Letter>());
		calledFreqs = new BarChartPartition<>(ALL_ROUNDS_EXCEPT_TOSS, ALL_LETTERS);
		repeatedLetters = new EnumMap<>(Round.class);
			for(Round r : MAINGAME) repeatedLetters.put(r, new LinkedList<Letter>());
		
		unusedRounds = new LinkedList<>(EnumSet.allOf(Round.class));	//thanks to EnumSet's guaranteed ordering, this works very well.
		currentRound = unusedRounds.remove();	//T1 starts game
	}
	
	public void setTitle(LocalDate showDate) {
		if(isDone)
			throw new AnalysisDoneException();
		
		this.showDate = showDate;
		showNumber = WheelDateFactory.showNumberFromDate(showDate);
		seasonNumber = ((showNumber-1)%195)+1;
		gameFileName = showDate.format(DateTimeFormatter.ofPattern("uu.MM.dd")) + ".wga";
		
		report.append((title = "Analysis of " + showDate.format(DateTimeFormatter.ofPattern("M/d/uu")) + ", #" + showNumber + ", #" + String.format("%03d", seasonNumber)) + "\n\n");
		for(char c : title.toCharArray()) report.append('~');
		report.append("\n\n\n");
	}
	
	public void setTitle(String date, String showN, String seasonN) throws NumberFormatException {
		if(isDone)
			throw new AnalysisDoneException();
		
		/** this stuff is pretty outdated, hence the overloaded method */
		Scanner scan = new Scanner(date).useDelimiter("/");
		int month = scan.nextInt(), day = scan.nextInt(), year = scan.nextInt();
		gameFileName = (year < 10 ? "0" : "") + year + "." + (month < 10 ? "0" : "") + month + "." + (day < 10 ? "0" : "") + day + ".wga";	//year < 10... heh. 2100? can also be used for '09
		
		showNumber = Integer.parseInt(showN);
		seasonNumber = Integer.parseInt(seasonN);
		
		report.append((title = "Analysis of " + date + ", #" + showN + ", #" + seasonN) + "\n\n");
		for(char c : title.toCharArray()) report.append('~');
		report.append("\n\n\n");
	}
	
	/**
	 * the following set of methods analyze a certain action in the game.
	 * the fields primarily attached to a particular method are defined before that method.
	 * there is some overlap/generalities (particularly some stats on all letters).
	 * see the StatList document for more details.
	 */
	
	Map<Wedge, PrizeEvent> prizeResults;
	
	BarChartPartition<Round, Wedge> spinLocations;
	BarChart<Round> leftRightMDWHits;
	BarChartPartition<Round, Player> lachTrash;
	Map<Wedge, List<Byte>> bigMoneyFreq;	//too late now but I probably should have bit the bullet and done a BarChartPartition<Wedge, Freq>
	Map<Wedge, Byte> wasteFreq;	//same as above; but now only for MDW in S30! for shame.
	Map<Player, List<Short>> spinStrengths;
	Map<Player, OneVarStats> spinStrengthStats;
	BarChart<FreePlayEvent> freePlayActions; 
	Wedge finalSpinLocation;
	short finalSpinStrength;
	WCUse wcUse;
	static class WCUse implements Serializable {
		private static final long serialVersionUID = 1L;
		
		Wedge w;
		Letter l;
		Byte freq;
		
		public WCUse(Wedge w, Letter l, Byte freq) {
			this.w = w;
			this.l = l;
			this.freq = freq;
		}
		
		public String toString() {
			return (w != null ? w : "BR") + ", " + (l != null ? l + ", " + (freq != null ? freq : "called") : "buzz out") + ".";	//updated 2/1/12
		}
	}
	MysteryRisk mysteryRisk;
	static class MysteryRisk implements Serializable {
		private static final long serialVersionUID = 1L;
		
		int riskedMoney, costOfRisk;
		Set<Wedge> riskedCardboard;
		boolean wasSuccessful;
		
		public MysteryRisk(int riskedMoney, Set<Wedge> riskedCardboard, Byte freq, boolean wasSuccessful) {
			this.riskedMoney = riskedMoney;
			this.riskedCardboard = EnumSet.copyOf(riskedCardboard);
			costOfRisk = 1000*freq;
			this.wasSuccessful = wasSuccessful;
		}
		
		public String toString() {
			return "Risked $" + riskedMoney + (!riskedCardboard.isEmpty() ? " and " +  formatCollection(riskedCardboard) : "") + " at the cost of $" + costOfRisk + " to find" +
				(wasSuccessful ? " cash" : " BANKRUPT") + "."
			;
		}
	}
	byte timesNotRisked = 0, timesNotRidden = 0, savedTurns = 0;	//from Free Play
	Wedge prizeReplacement;		public void setPrizeReplacement(Wedge prizeReplacement) { this.prizeReplacement = prizeReplacement; }	//this is purely for MultiGameAnalysis
	private transient boolean freePlayFlag = false;
	
	/** specialFlag should be true on the following: Mystery RISK FAILURE, Express RUN RISKED, Free Play SOLVE ATTEMPTS. */
	public void analyzeSpin(Player p, Wedge w, Letter l, Byte freq, short spinStrength, boolean specialFlag) {
		if(isDone)
			throw new AnalysisDoneException();
		
		if(p == null) {	//Pat
			finalSpinLocation = w;
			finalSpinStrength = spinStrength;
			return;
		}
		
		boolean goodCall = freq != null && freq != 0;
		
		if(spinStrength != 0) {
			spinStrengths.get(p).add(spinStrength);
			spinLocations.add(currentRound, w);
			
			if(Wedge.isBlack(w)) {
				analyzeBankrupt(p);
				if(w == Wedge.MillionDollarWedge)
					leftRightMDWHits.addY(currentRound);
			} else if(CARDBOARD.contains(w)) {	//else if avoids left/right MDW issues
				if(MYSTERY.contains(w)) {
					if(!w.isActive()) {
						Set<Wedge> riskedCardboard = p.getAllCardboard();
						riskedCardboard.remove(w);
						mysteryRisk = new MysteryRisk(p.getRoundScore(), riskedCardboard, freq, !specialFlag);
						
						if(specialFlag) {
							analyzeBankrupt(p);
							prizeResults.put(w, PrizeEvent.Was_bankrupt);
						} else
							prizeResults.put(w, PrizeEvent.Picked_up);
						
						prizeResults.put(w == Wedge.Purple1000_1 ? Wedge.Purple1000_2 : Wedge.Purple1000_1, PrizeEvent.Retired_from_risk);
					} else if(prizeResults.get(w) != PrizeEvent.Retired_from_risk) {
						prizeResults.put(w, PrizeEvent.Not_picked_up);
						if(goodCall)
							timesNotRisked++;
					}
				} else {
					prizeResults.put(w, goodCall ? PrizeEvent.Picked_up : PrizeEvent.Not_picked_up);
					if(WASTE.contains(w) && goodCall)
						wasteFreq.put(w, freq);
				}
			} else if(w == Wedge.FreePlay) {
				if(l != null) {
					freePlayActions.addY(Letter.CONSONANTS.contains(l) ? FreePlayEvent.Consonant : FreePlayEvent.Vowel);
					if(!goodCall) savedTurns++;
				} else if(specialFlag) {
					freePlayActions.addY(FreePlayEvent.Solve_attempt);
					freePlayFlag = true;	//analyzeSolveAttempt uses this on a missolve. See missolve branch of RecordGamePanel.RoundListener.
				} else {
					freePlayActions.addY(FreePlayEvent.Buzzed);
					savedTurns++;
				}
			}
		} else {
			prizeResults.put(Wedge.WildCard, PrizeEvent.Used);
			wcUse = new WCUse(w == Wedge.WildCard ? Wedge.Green500_3 : w, l, freq);	//12/26/13: wtf
		}
		
		if(BIG_MONEY.contains(w))
			bigMoneyFreq.get(w).add(freq);
		
		if(l != null)
			analyzeCall(p, l, freq);
		
		if(w == Wedge.Express) {
			if(specialFlag) {	//NOW process an express ride after the initial call.
				ExpressRide eR = expressRides.getLast();
				for(Map.Entry<Letter, Byte> e : eR.ride.entrySet())
					analyzeCall(p, e.getKey(), e.getValue());
				Optional.ofNullable(eR.derailReason).ifPresent(dR -> analyzeBankrupt(p));
			} else if(goodCall)
				timesNotRidden++;
		}
	}
	
	private void analyzeBankrupt(Player p) {
		lachTrash.add(currentRound, p, p.getRoundScore());
		for(Wedge wedge : p.getCardboard(false))
			prizeResults.put(wedge, PrizeEvent.Bankrupted);
		for(Wedge wedge : p.getCardboard(true))
			//if(!Wedge.HALFCARS.contains(wedge))
				prizeResults.put(wedge, PrizeEvent.Bankrupted_after_claimed);
	}
	
	LinkedList<ExpressRide> expressRides;
	static class ExpressRide implements Serializable {
		private static final long serialVersionUID = 1L;
		
		//this data encapsulation currently FAILS if a repeat of a letter occurs and the original call was during the same ride.
		Player p;
		LinkedHashMap<Letter, Byte> ride;	//in order of calling! not a BarChart as well because of potential repeat (use BarChart of Freqs in MultiGame).
		int riskedMoney, rideEarnings;
		Set<Wedge> riskedCardboard;
		DerailReason derailReason = null;	//null iff successful ride. if dud/repeat, the last letter of ride is the "derailing" letter, retrievable by wrapping the keySet into a list.
		
		public ExpressRide(Player p, LinkedHashMap<Letter, Byte> ride, int riskedMoney, Set<Wedge> riskedCardboard, boolean wasSuccessful, boolean wasMissolve) {
			this.p = p;
			this.ride = ride;
			this.riskedMoney = riskedMoney;
			this.riskedCardboard = riskedCardboard;
			
			rideEarnings = 0;
			for(Letter l : ride.keySet()) {
				Optional<Byte> f = Optional.ofNullable(ride.get(l));
				if(!f.isPresent())	
					derailReason = DerailReason.Repeat;
				else if(f.get() == 0)
					derailReason = DerailReason.Dud;
				
				if(f.isPresent() && Letter.CONSONANTS.contains(l))
					rideEarnings += 1000*f.get();
				else if(Letter.VOWELS.contains(l))
					rideEarnings -= 250;	//so vowel frequency isn't a big deal on the individual scale, I'll probably do it on the multi-game scale though
			}
			
			if(!wasSuccessful && derailReason == null)
				derailReason = wasMissolve ? DerailReason.Missolve : DerailReason.Buzzout;
		}
		
		public String toString() {
			Set<Letter> letters = ride.keySet(); LinkedList<Letter> letterList = new LinkedList<>(letters);
			Map<Boolean, List<Letter>> m1 = letters.stream().collect(Collectors.partitioningBy(l -> Letter.CONSONANTS.contains(l)));	//true for consonants, false for vowels
			int consonants = m1.get(true).stream().collect(Collectors.summingInt(l -> { Byte bf = ride.get(l); int fi = bf == null ? 0 : bf.intValue(); return fi; })),
				vowels = m1.get(false).size();
			Letter first = letterList.getFirst(), last = letterList.getLast();
			
			return p + " risked $" + riskedMoney + (!riskedCardboard.isEmpty() ? " (as well as " +  formatCollection(riskedCardboard) + ")" : "") +
			", called " + (first == last ? "1 letter (" + first : (letterList.size() + " letters (" + first + " to " + last)) +
			"), and found " + consonants + " consonant(s) in the puzzle while calling " + vowels + " vowel(s), " +
			(derailReason == null ? "successfully completing the ride for a net earnings of $" : "for a net ride earnings of $") + rideEarnings + "." + 
			(derailReason != null ? " The ride was derailed by a " + String.valueOf(derailReason).toLowerCase() + 
			(derailReason.ordinal() <= 1 ? " " + last : "") + "." : "");	//Dud or Repeat, of course
		}
	}
	
	public void analyzeExpressRide(Player p, LinkedHashMap<Letter, Byte> ride, int riskedMoney, boolean wasSuccessful, boolean wasMissolve) {
		if(isDone)
			throw new AnalysisDoneException();
		
		expressRides.add(new ExpressRide(p, ride, riskedMoney, p.getAllCardboard(), wasSuccessful, wasMissolve));
	}
	
	BarChartPartition<Player, Letter> calledByPlayer;
	Map<Round, List<Letter>> calledByRound, repeatedLetters;
	BarChartPartition<Round, Letter> calledFreqs;
	
	public void analyzeCall(Player p, Letter l, Byte freq) {
		if(isDone)
			throw new AnalysisDoneException();
		
		if(currentRound != Round.BR) {
			calledByPlayer.add(p, l);
			
			if(!calledByRound.get(currentRound).contains(l)) {
				calledByRound.get(currentRound).add(l);
				if(freq != 0) {
					puzzleDissections.add(currentRound, l, freq);
					calledFreqs.add(currentRound, l, freq);
				}
			} else
				repeatedLetters.get(currentRound).add(l);	//while a search through Letter.values() of Collections.frequency(calledByRound, l) could be used to sum repeatedLetters, this is a costly operation.
		} else
			calledByRound.get(currentRound).add(l);
	}
	
	BarChart<Round> winnings, missolves, lostTurns;
	BarChartPartition<Round, Letter> puzzleDissections;
	BarChartPartition<Round, Player> lostBanks;
	Map<Round, HighestMultiples> highestMultLetters;
	static class HighestMultiples implements Serializable {
		private static final long serialVersionUID = 1L;	//version number.
		
		Set<Letter> multiples;
		byte max;
		
		public HighestMultiples(BarChart<Letter> dissection, Set<Letter> letterPool, boolean completelyFilled) {
			multiples = EnumSet.noneOf(Letter.class);
			if(completelyFilled) {
				max = 0;
				return;	//boolean parameter is quicker than doing dissection.getY(letterPool) == 0, as seen below blanks == 0 is perfect
			}
			
			max = 2;	//we're interested in 2 or more
			
			for(Letter l : letterPool) {
				byte freq = dissection.getY(l).byteValue();
				
				if(freq >= max) {
					if(freq	> max) {
						multiples.clear();
						max = freq;
					}
					multiples.add(l);
				}
			}
			
			if(multiples.isEmpty())
				max = 1;
		}
		
		public String toString() {
			return (!multiples.isEmpty() ? max + ": " +  formatCollection(multiples) : "------");
		}
	}
	Map<Round, PuzzleInfo> puzzleDetails;
	class PuzzleInfo implements Serializable {
		private static final long serialVersionUID = 1L;	//version number.
		
		PuzzleBoard puzzleBoard;
		byte blanks = 0, total, vowels = 0, lines = 1;	//none of these definitely going over 127, save some memory
		BigDecimal filledPercent, vowelPercent;
		
		public PuzzleInfo(Puzzle p, Round r) {
			String pString = p.toString().replaceAll("<br>", "\n");
			BarChart<Letter> thisDissection = puzzleDissections.getY(r);
			
			//for maingame/BR puzzles, some processing involving letters not called is also done here, thus why this isn't a static nested class.
			if(!TOSSUPS.contains(r)) {
				EnumSet<Letter> called = EnumSet.copyOf(calledByRound.get(r));
				p.updatePuzzle(called);
				
				EnumSet<Letter> uncalled = EnumSet.complementOf(called);
				BarChart<Letter> thisCalledFreqs = calledFreqs.getY(r);
				thisCalledFreqs.removeX(uncalled);
				for(Letter l : Letter.values()) {
					byte freq = (byte) frequencyOfChar(pString, l.getChar());
					if(uncalled.contains(l)) {
						if(freq != 0) {
							thisDissection.addY(l, freq);
							blanks += freq;
						}
					} else if(isMainGame() && thisCalledFreqs.getY(l).byteValue() != freq)
						throw new IllegalArgumentException("Letter " + l + " does not match called frequency of " + calledFreqs.getY(r).getY(l) + " in puzzle");
				}
				
				if(isMainGame()) {
					EnumSet<Letter> uncalledConsonants = EnumSet.copyOf(uncalled);
					uncalledConsonants.removeAll(Letter.VOWELS);	//or retainAll(Letter.CONSONANTS)
					highestMultLetters.put(r, new HighestMultiples(thisDissection, uncalledConsonants, blanks == 0));
				} else {	//BR adjustments: fill in called letters manually; adjust blanks for RSTLNE
					for(Letter l : calledByRound.get(r)) {
						byte freq = (byte) frequencyOfChar(pString, l.getChar());
						if(freq != 0) {
							calledFreqs.add(r, l, freq);
							thisDissection.addY(l, freq);
						}
					}
					
					blanks -= (rstlneGiven = thisDissection.getY(BonusPuzzle.GIVEN).byteValue());	//rstlneGiven is useful for MultiGameAnalysis without redundant calculations
					
					if(prizeResults.get(Wedge.WildCard) == PrizeEvent.Went_to_BR) {	//prizeResults is updated AFTER puzzleDetails, so this is safe.
						//reduce to ignore accumulation - making the returning Optional essentially a getLast of the stream.
						Letter wcl = calledByRound.get(r).stream().filter(l -> Letter.CONSONANTS.contains(l)).reduce((ignore, last) -> last).get();
						wcUse = new WCUse(null, wcl, calledFreqs.getY(r).getY(wcl).byteValue());
					}
				}
				
				total = (byte) puzzleDissections.getY(r).getTotalY();
			} else {
				total = 0;
				for(char c : pString.toCharArray())
					if(Character.isUpperCase(c)) { puzzleDissections.add(r, Letter.getLetter(c)); total++; }
				
				blanks = (byte) frequencyOfChar(p.getPuzzle(), '_');
			}
			
			filledPercent = new BigDecimal(100*(1 - ((double)blanks)/total)).setScale(1, RoundingMode.HALF_UP);
			
			vowels = thisDissection.getY(Letter.VOWELS).byteValue();
			
			vowelPercent = new BigDecimal(100*((double)vowels)/total).setScale(1, RoundingMode.HALF_UP);
			
			lines += (byte) frequencyOfChar(pString, '\n');
			
			puzzleBoard = new PuzzleBoard(p);
		}
		
		public String toString() {
			return total + " letters, " + (total - blanks) + " filled (" + filledPercent + "%), " + vowels + " vowels (" + vowelPercent + "%), in " + lines + " line" + (lines > 1 ? "s" : "") + ".";
		}
	}
	byte rstlneGiven;
	Map<Round, Player> roundWinners;
	Set<Round> perfectRounds, allVowelsBought, allConsonantsCalled;
	boolean tossUpSweep;
	
	/** null arguments mean: pl - triple stumper on toss-up; pu - missolve. pu takes precedence (if pu is null, pl doesn't matter) */
	public void analyzeSolveAttempt(Player pl, Puzzle pu) {
		if(isDone)
			throw new AnalysisDoneException();
		
		if(pu != null) {
			roundWinners.put(currentRound, pl);
			if(currentRound == Round.T3)
				tossUpSweep = pl == roundWinners.get(Round.T2) && pl == roundWinners.get(Round.T1);
			
			if(currentRound != Round.BR && currentRound != Round.TT && pl != null)	//BR is taken care of in analyzeBonus.
				winnings.addY(currentRound, isMainGame() ? pl.getRoundScore() : currentRound == Round.T3 ? 3000 : (currentRound.ordinal()+1)*1000);
			else if(currentRound == Round.TT && pl != null) {
				winner = pl;
			}
			puzzleDetails.put(currentRound, new PuzzleInfo(pu, currentRound));	//see constructor above for puzzleDissection and calledFreqs finishing. also note WC BR use relies on positioning here
			
			if(isMainGame()) {
				for(Wedge w : pl.getCardboard(false))
					prizeResults.put(w, PrizeEvent.Claimed);
				for(Player player : complementOfEnum(pl)) {
					lostBanks.add(currentRound, player, player.getRoundScore());
					for(Wedge w : player.getCardboard(false))
						prizeResults.put(w, PrizeEvent.Retired);
				}
				
				/* regular black and white, left/right MDW bankrupts, all duds (done after PuzzleInfo processes), and main buzzes. Did I get everything? :P
				   update on 9/22/11 - no, you forgot repeated letters AND mystery fails ya doof!
				   update on 9/1/13 - how the fuck did you forget missolves you fucking dumbass */
				int thisLostTurns = spinLocations.getY(currentRound).getY(BW) + (currentRound.ordinal() < Round.R4.ordinal() ? leftRightMDWHits.getY(currentRound) : 0) + 
					Collections.frequency(calledFreqs.getY(currentRound).getYs(), 0) + (isMysteryActive() && mysteryRisk != null && !mysteryRisk.wasSuccessful ? 1 : 0) +
					repeatedLetters.get(currentRound).size() + mainBuzzes.getY(currentRound) + missolves.getY(currentRound);
				lostTurns.addY(currentRound, thisLostTurns);
				//I would hope that somehow only (correct) vowels called by the other players would never happen to trick this code
				if(thisLostTurns == 0 && lostBanks.getY(currentRound).getTotalY() == 0)
					perfectRounds.add(currentRound);
				
				EnumSet<Letter> calledVowels = EnumSet.copyOf(calledByRound.get(currentRound)), calledConsonants = EnumSet.copyOf(calledVowels),
					uncalledVowels = EnumSet.copyOf(Letter.VOWELS), uncalledConsonants = EnumSet.copyOf(Letter.CONSONANTS);
				calledVowels.retainAll(Letter.VOWELS);
				calledConsonants.retainAll(Letter.CONSONANTS);
				uncalledVowels.removeAll(calledVowels);
				uncalledConsonants.removeAll(calledConsonants);
				
				BarChart<Letter> thisDissection = puzzleDissections.getY(currentRound);
				if(thisDissection.getY(uncalledVowels) == 0)
					allVowelsBought.add(currentRound);
				if(thisDissection.getY(uncalledConsonants) == 0)
					allConsonantsCalled.add(currentRound);
			}
		} else {
			missolves.addY(currentRound);
			if(freePlayFlag)
				savedTurns++;
		}
			
		freePlayFlag = false;
	}
	
	BarChart<Round> mainBuzzes, tossUpBlanks;
	
	//the *BZZ BZZ* of a BR loss is taken care of in analyzeSolveAttempt.
	//Player p is kept here just for consistency, a dead argument after deciding not to track buzzes by color.
	public void analyzeBuzz(Player p) {
		if(isDone)
			throw new AnalysisDoneException();
		
		if(isMainGame()) {
			mainBuzzes.addY(currentRound);
		} else
			tossUpBlanks.addY(currentRound);
	}
	
	Map<Round, Category> roundCat;
	short catPlurality = 0;
	BarChart<Player> finalMainWinnings;
	Player winner, second = null, third;
	Round pp;
	short pWheelAmount = 0, ppAmount;
	int halfCarAmount = 0, brCarAmount = 0, winningMargin, secondaryMargin, amountOverMinimum;	//luxury cars exceed short
	boolean ppIsWinner, didPPMatter = false, speedUpComeback;
	byte gooseEggs = 0;
	
	public void analyzePrizeOnWheel(int amount) {
		pWheelAmount = (short) amount;
	}
	
	/** amount - PW, PP or BR car, amount2 - half car. return value - if we have a tie at the end of the maingame. */
	public boolean analyzeRound(Category c, int amount, int amount2) {
		if(isDone)
			throw new AnalysisDoneException();
		
		roundCat.put(currentRound, c);
		if(Category.isCurrentlyPlural())
			catPlurality |= 1 << currentRound.ordinal();
		
		if(amount != 0) {
			switch(currentRound) {
				case R1: case R2:
					pWheelAmount = (short) amount;
					break;
				case R3: //case R2: case R1:
					ppAmount = (short) amount;
					//pp = currentRound;
					break;
				case BR:
					brCarAmount = amount;
			}
			
			if(currentRound != Round.T2)
				winnings.addY(currentRound, amount);
		}
		
		if(amount2 != 0) {
			halfCarAmount = amount2;
			
			EnumSet<Wedge> winnerPermBoard = roundWinners.get(currentRound).getCardboard(true);
			for(Wedge w : Wedge.HALFCARS)
				if(prizeResults.get(w) == PrizeEvent.Claimed)
					prizeResults.put(w, winnerPermBoard.contains(w) ? PrizeEvent.Completed : PrizeEvent.Abandoned);
			
			winnings.addY(currentRound, amount2);
		} else if(currentRound == Round.R3 && halfCarAmount == 0)
			for(Wedge w : Wedge.HALFCARS)
				if(prizeResults.get(w) == PrizeEvent.Claimed)
					prizeResults.put(w, PrizeEvent.Abandoned);
		
		if(finalSpinLocation != null && currentRound != Round.BR) {	//end of maingame processing.
			if(currentRound != Round.TT) {
				for(Player p : ALL_PLAYERS) {	//various processing here
					spinStrengthStats.put(p, new OneVarStats(spinStrengths.get(p)));
					if(!roundWinners.containsValue(p))
						gooseEggs++;
					
					finalMainWinnings.addY(p, p.getTotalScore());
				}
				
				Player[] playersByTotal = Player.values();
				Arrays.sort(playersByTotal, Player.SCORE_COMPARATOR);
				
				third = playersByTotal[0];
				second = playersByTotal[1];
				winner = playersByTotal[2];
				
				switch(new HashSet<Integer>(finalMainWinnings.getYs()).size()) {
					case 2:
						if(Player.isTied(third, second)) {
							decideLoserTie(complementOfEnum(winner), finalMainWinnings.getY(second));
							break;
						}
						//tie for first/second: tiebreaker toss-up, fall through
					case 1:	//three-way tie.
						currentRound = Round.TT;
						third = second = winner = null;
						return true;
				}
			} else if(winner != null) {
				//was this a tie for first/second, or all three? with second and third = null, some workarounds are needed.
				if(Player.areLosersTied(winner))	//all three
					decideLoserTie(complementOfEnum(winner), Collections.min(finalMainWinnings.getYs()));
				else {	//second is obviously who matches winner in winnings, and third will have less.
					Arrays.stream(Player.values()).filter(p -> p != winner).forEach(p -> {
						if(finalMainWinnings.getY(p).equals(finalMainWinnings.getY(winner)))	//.equals required due to Integer
							second = p;
						else
							third = p;
					});
				}
			} else
				return true;
			
			winningMargin = finalMainWinnings.getY(winner) - finalMainWinnings.getY(second);
			secondaryMargin = finalMainWinnings.getY(second) - finalMainWinnings.getY(third);
			
			for(Wedge w : winner.getCardboard(true))
				prizeResults.put(w, PrizeEvent.Went_to_BR);
			
			Set<Wedge> lostCardboard = EnumSet.copyOf(second.getCardboard(true));
			lostCardboard.addAll(third.getCardboard(true));
			for(Wedge w : lostCardboard)
				prizeResults.put(w, PrizeEvent.Lost_maingame);
			
			if(ppIsWinner = winner == roundWinners.get(pp))
				didPPMatter = winningMargin <= ppAmount;
			
			speedUpComeback = winner == roundWinners.get(currentRound) && winningMargin < winnings.getY(currentRound);
			
			amountOverMinimum = -6000 - ppAmount;
			ALL_ROUNDS_EXCEPT_BR.stream()
				.forEach(r -> Optional.ofNullable(winnings.getY(r))
					.ifPresent(w -> amountOverMinimum += w - (MAINGAME.contains(r) && r != pp ? (males + females == 3 ? 1000 : 2000) : 0)));
			
			currentRound = unusedRounds.removeLast();	//BR.
		} else
			currentRound = bonusWedge == null ? unusedRounds.remove() : null;
		
		if(currentRound == null) {	//final processing!
			spinLocations.remove0s();
			leftRightMDWHits.remove0s();
			freePlayActions.remove0s();
			calledByPlayer.remove0s();
			missolves.remove0s();
			puzzleDissections.remove0s();
			lachTrash.remove0s();
			lostBanks.remove0s();
			mainBuzzes.remove0s();
			tossUpBlanks.remove0s();
			
			if(!unusedRounds.isEmpty()) {
				Set<Round> uR = EnumSet.copyOf(unusedRounds);
				lostTurns.removeX(uR);
				winnings.removeX(uR);
				calledFreqs.getXs().removeAll(uR);
				
				for(Round r : uR) {
					calledByRound.remove(r);
					repeatedLetters.remove(r);
				}
			}
			
			 removeEmptyValuesFromMap(repeatedLetters);
			 removeEmptyValuesFromMap(bigMoneyFreq);
					
			
			synthesizeGame();
		}
		
		return false;
	}
	
	TriviaBonus triviaBonus;
	static class TriviaBonus implements Serializable {
		private static final long serialVersionUID = 1L;	//version number.
		
		Category triviaCat;
		boolean wasTriviaRight;
		
		private String infoString;
		
		public TriviaBonus(Category triviaCat, boolean wasTriviaRight) {
			this.triviaCat = triviaCat;
			this.wasTriviaRight = wasTriviaRight;
			
			infoString = triviaCat + ", " + (!wasTriviaRight ? "in" : "") + "correct.";
		}
		
		public String toString() {
			return infoString;
		}
	}
	public void analyzeTrivia(Category triviaCat, boolean wasTriviaRight) {
		if(isDone)
			throw new AnalysisDoneException();
		
		triviaBonus = new TriviaBonus(triviaCat, wasTriviaRight);
		
		if(wasTriviaRight)
			winnings.addY(currentRound, 3000);
	}
	
	int jackpotAmount;
	boolean wasJackpotWon;
	
	public void analyzeJackpot(int jackpotAmount, boolean wasJackpotWon) {
		if(isDone)
			throw new AnalysisDoneException();
		
		this.jackpotAmount = jackpotAmount;
		this.wasJackpotWon = wasJackpotWon;
	}
	
	BonusWedge bonusWedge;
	BonusAmount bonusAmount;
	
	public void analyzeBonus(BonusWedge bW, BonusAmount bA) { analyzeBonus(bW, bA, false); }
	public void analyzeBonus(BonusWedge bW, BonusAmount bA, boolean loweredVehicleBonus) {
		if(isDone)
			throw new AnalysisDoneException();
		
		bonusWedge = bW;
		bonusAmount = bA;
		Optional.ofNullable(roundWinners.get(Round.BR)).ifPresent(p ->
			winnings.addY(Round.BR, bA == BonusAmount.VEHICLE ? (showNumber > 6240 ? 0 : (loweredVehicleBonus ? 3000 : 5000)) : bA.getAmount())
		);
	}
	
	byte females, males;
	
	public void analyzeGender(int females, boolean isCouples) {
		if(isDone)
			throw new AnalysisDoneException();
		
		this.females = (byte) females;
		males = (byte) ((!isCouples ? 3 : 6) - females);
	}

	/* the following are a couple helper methods for processes on stats. */
	
	private boolean isMainGame() {
		return MAINGAME.contains(currentRound);
	}
	
	private boolean isTossUp() {
		return TOSSUPS.contains(currentRound);
	}
	
	private boolean isMysteryActive() {
		return Wedge.Purple1000_1.isActive() || Wedge.Purple1000_2.isActive();
	}
	
	private void decideLoserTie(EnumSet<Player> losers, int tyingAmount) {
		List<Player> tiedPlayers = new LinkedList<>(losers), l = new LinkedList<>(roundWinners.values());
		int lastRound0 = l.lastIndexOf(tiedPlayers.get(0)), lastRound1 = l.lastIndexOf(tiedPlayers.get(1));
		
		//this isn't terribly clean-looking, but it's the most clear
		if(lastRound0 == lastRound1) {	//both -1, clean sweep - just go ahead and arbitrarily give it to leftmost player
			second = tiedPlayers.get(0);
			third = tiedPlayers.get(1);
		} else if(lastRound0 == -1) {	//Player 0 goosed, 0 is 3rd
			third = tiedPlayers.get(0);
			second = tiedPlayers.get(1);
		} else if(lastRound1 == -1) {	//Player 1 goosed, 1 is 3rd
			third = tiedPlayers.get(1);
			second = tiedPlayers.get(0);
		} else {	//each won at least one round, give whoever first reached the tied amount 2nd
			third = lastRound0 > lastRound1 ? tiedPlayers.get(0) : tiedPlayers.get(1);
			second = lastRound0 < lastRound1 ? tiedPlayers.get(0) : tiedPlayers.get(1);
			
			//exception: in a doubles game, one team wins 1k, another wins 2k/minimum round, second should go to latter team, not former
			if(males + females == 6 && tyingAmount == 2000 && l.lastIndexOf(third) == 0) {
				Player temp = second;
				second = third;
				third = temp;
			}
		}
	}
	
	/* end helper methods */
	
	/* utility methods */
	
	private static int frequencyOfChar(String s, char c) {
		int freq = 0, pos = 0;
		while((pos = s.indexOf(c, pos) + 1) != 0)
			freq++;
		
		return freq;
	}
	
	private static <E extends Enum<E>> EnumSet<E> complementOfEnum(E e) {
		return EnumSet.complementOf(EnumSet.of(e));
	}
	
	/* end utility methods */
	
	private void synthesizeGame() {
		synthesizeGame(false);
	}
	
	private void synthesizeGame(boolean override) {
		if(isDone && !override)
			throw new AnalysisDoneException();
		if(override)
			report.delete(report.indexOf("~\n\n\n")+4, report.length());	//keep title
		
		BarChart<Wedge> allSpins = spinLocations.synthesizeTotalY();
		report.append("Spin locations by contestants for all rounds:\n" + allSpins);
		if(allSpins.getY(Wedge.MillionDollarWedge) != null)
			report.append(LINE + "Of MDW hits above, left/right hits:\n" + leftRightMDWHits);
		report.append(LINE + "Called letters by round for maingame:\n" +  formatMap(calledByRound, MAINGAME));
		report.append(LINE + "Called letters' total frequency for maingame:\n" + calledFreqs.synthesizeY(MAINGAME));
		report.append(LINE + "\"No more vowels\" occurred " + allVowelsBought.size() + " time(s), and \"no more consonants\" occurred " + allConsonantsCalled.size() + " time(s).");
		report.append(LINE + "Total letter calls by each player:\n" + calledByPlayer);
		report.append(LINE + "Big money letters' frequencies:\n" +  formatMap(bigMoneyFreq));
		if(!repeatedLetters.isEmpty())
			report.append(LINE + "Repeated letters:\n" +  formatMap(repeatedLetters));
		report.append(LINE + "Highest multiple(s) left:\n" +  formatMap(highestMultLetters));
		report.append(LINE + "Spin strength stats*:\n" +  formatMap(spinStrengthStats));
		report.append(LINE + "$ lost due to Bankrupt:\n" + lachTrash);
		report.append(LINE + "Retired banks:\n" + lostBanks);
		if(mainBuzzes.getTotalY() > 0)
			report.append(LINE + "Maingame buzz outs:\n" + mainBuzzes);
		report.append(LINE + "Total lost turns:\n" + lostTurns);
		report.append(LINE + "What happened to the cardboard:\n" +  formatMap(prizeResults));
		
		//just having some fun with equivalent code, Optionals are a cool addition to java.util in Java 8
		Optional.ofNullable(wcUse).ifPresent(wcU -> report.append(LINE + "Wild Card use: " + wcU));
		Optional.ofNullable(mysteryRisk).ifPresent(mR -> report.append(LINE + "Mystery risk: " + mR));
		Optional.ofNullable(expressRides).filter(eRs -> eRs.size() > 0).ifPresent(eRs -> {
			report.append(LINE + "The Express was ridden ");
			int j = eRs.size();
			switch(j) {
				case 1: report.append("once!\n"); break;
				case 2: report.append("twice!\n"); break;
				case 3: report.append("thrice!\n"); break;
				default: report.append(j + " times! Wow!!\n");
			}
			report.append("\nR3 called letters again: " + formatCollection(calledByRound.get(Round.R3)));
			if(repeatedLetters.get(Round.R3) != null)	//repeatedLetters have removeEmptyValuesFromMap done in analyzeRound of BR
				report.append("\nR3 repeated letter(s) again: " + formatCollection(repeatedLetters.get(Round.R3)));
			for(int i = 1; i <= j; i++)
				report.append("\n\n" + i + ". " + eRs.get(i-1));
		});
		
		if(!wasteFreq.isEmpty())
			report.append(LINE + "Wasted frequency (as of S30, only applies to MDW):\n" +  formatMap(wasteFreq));
		if(freePlayActions.getTotalY() > 0)
			report.append(LINE + savedTurns + " of these Free Play actions saved turns:\n" + freePlayActions);
		
		if(tossUpBlanks.getTotalY() > 0)
			report.append(LINE + "Toss up \"blanks\":\n" + tossUpBlanks);
		if(missolves.getTotalY() > 0)
			report.append(LINE + "Missolves:\n" + missolves);
		
		report.append(LINE + "BR called letters' frequencies: \n" + calledFreqs.toPartialString(BONUS_ROUND));
		
		
		report.append(LINE + "The prize puzzle winner " + (ppIsWinner ? "won the maingame, and the prize puzzle " + (didPPMatter ? "DID" : "did not") + " matter." : "did not win the maingame."));
		if(speedUpComeback)
			report.append(LINE + "There was a speed-up comeback.");
		report.append(LINE + "Order of finish: " + winner + ", " + second + ", " + third + "\n\nNow the corresponding maingame totals:\n" + finalMainWinnings);
		report.append(LINE + "Round winners:\n" +  formatMap(roundWinners));
		BarChart<Round> bC = winnings.clone();
		bC.removeX(TOSSUPS);
		report.append(LINE + "Round winnings (if toss-ups are not listed, assume usual; add $6000 to TOTAL line for total winnings this show):\n" +
			(winnings.getY(TOSSUPS) == 6000 ? bC : winnings)
		);
		
		report.append(LINE + "Categories:\n" +  formatMap(roundCat, (r, c) -> Category.setPlural(wasCatPlural(r))));
		report.append(LINE + "Puzzle dissections:\n" + puzzleDissections);
		report.append(LINE + "Miscellaneous puzzle info:\n" +  formatMap(puzzleDetails));
		
		//report.append(DISCLAIMER);
		
		report.trimToSize();
		isDone = true;
	}
	
	/* special function to determine nada letters in BR. note how this only can return true from a non-serialized instance. */
	
	public boolean areBRLettersNada() {
		return currentRound == Round.BR && calledFreqs.getY(Round.BR).getTotalY() == 0;
	}
	
	//not meant to be called until after isDone, so package private - for multi-game only
	int getNumberOfMGRounds() {
		return calledByRound.size() - 1;
	}
	
	//same here
	Round getSpeedUpRound() {
		Round r = Round.R7;
		for(int i = 7; !calledByRound.containsKey(r); r = Enum.valueOf(Round.class, "R" + --i));
		return r;
	}
	
	public LocalDate getShowDate() {
		return showDate;
	}
	
	public String showDateString() {
		return showDate.format(DateTimeFormatter.ofPattern("M/d/uu"));
	}
	
	public int getShowNumber() {
		return showNumber;
	}
	
	public int getSeasonNumber() {
		return seasonNumber;
	}
	
	public int getSeason() {
		return ((showNumber - 1) / 195) + 1;
	}
	
	public String getShowInfo() {
		return showDateString() + ", #" + showNumber + " (S" + getSeason() + " E" + String.format("%03d", seasonNumber) + ")";
	}
	
	public String getTitle() {
		return title;
	}
	
	public String getFileName() {
		return gameFileName;
	}
	
	public int compareTo(GameAnalysis rhs) {
		return showNumber - rhs.getShowNumber();
	}
	
	public boolean equals(Object o) {
		if(!(o instanceof GameAnalysis))
			return false;
		
		return showNumber == ((GameAnalysis) o).getShowNumber();
	}
	
	public StringBuilder getReport() {
		return report;
	}
	
	//return value (where it's ultimately written to) is used in ReadoutPanel
	public File writeAnalysis(boolean overWrite) throws IOException {
		String dir = "analysis\\s" + getSeason() + "\\";
		File f = new File(dir + gameFileName.replace("ser", "wga"));
		Object o = new Object();	//dummy for first pass-through of condition
		while(!overWrite && (f.exists() || o == null))
			f = new File(dir + (o = JOptionPane.showInputDialog(MainWindow.getWindow(), "An analysis for this date has already been written.\n\nRename (should end in .wga):",
				"Rename Analysis File", JOptionPane.WARNING_MESSAGE, null, null, gameFileName))
			);
		try(FileOutputStream analysisWriter = new FileOutputStream(f); ObjectOutputStream persistance = new ObjectOutputStream(analysisWriter)) {
			//if(overWrite)
				//f.setWritable(true);
			persistance.writeObject(this);
		} catch(InvalidClassException | NotSerializableException e) {
			e.printStackTrace();
			JOptionPane.showMessageDialog(null, "The analysis object was NOT saved properly.", "Error saving analysis", JOptionPane.ERROR_MESSAGE);
		}
		
		//if(!overWrite)
			//f.setReadOnly();	setReadOnly is a bit archaic, can't change it back in code
		
		return f;
	}
	
	public File writeAnalysis() throws IOException {
		return writeAnalysis(false);
	}
	
	public void writeReport() throws IOException {
		try(FileWriter fW = new FileWriter(new File("analysis\\reports\\" + showNumber + ".txt"))) {
			fW.write(report.toString());
		}
	}
	
	public static GameAnalysis readAnalysis(File f) {
		try(FileInputStream analysisReader = new FileInputStream(f); ObjectInputStream persistance = new ObjectInputStream(analysisReader)) {
			return (GameAnalysis) persistance.readObject();
		} catch(IOException | ClassNotFoundException e) {
			return null;
		}
	}
	
	public String toString() {
		return report.toString();
	}
	
	/* below are special correction methods to only be used by me */
	
	private boolean dumpAnalysis() {
		try {
			try(FileWriter fW = new FileWriter(new File("analysis\\temp\\" + gameFileName + " temp.txt"))) {
				fW.write("This is a temporary dump of all the fields but the report of this GameAnalysis, for error checking only.\n\n\n");
				for(Field f : getClass().getDeclaredFields()) {
					int modifiers = f.getModifiers();
					if(!Modifier.isPrivate(modifiers) && !Modifier.isStatic(modifiers) && !Modifier.isTransient(modifiers) && !f.getName().equals("report"))
						fW.write(f + "\n" + f.get(this) + "\n\n");
				}
			}
		} catch(Exception e) {
			e.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	//kinda lazy on my part...
	public Map<Round, Category> getCategoryMap() { return Collections.unmodifiableMap(roundCat); }
	public Map<Player, List<Short>> getSpinStrengths() { return Collections.unmodifiableMap(spinStrengths); }
	public void setSpinStrengths(Map<Player, List<Short>> spinStrengths) { this.spinStrengths = spinStrengths; }
	public BarChartPartition<Round, Letter> getPuzzleDissections() { return puzzleDissections.clone(); }
	public EnumMap<Round, PuzzleBoard> getPuzzles() {
		EnumMap<Round, PuzzleBoard> m = new EnumMap<>(Round.class);
		this.puzzleDetails.forEach((r, pD) -> m.put(r, pD.puzzleBoard));
		return m;
	}
	public boolean wasCatPlural(Round r) {
		return (catPlurality & 1 << r.ordinal()) != 0;
	}
	
	//lazy test / correction area, GO!
	public static void main(String[] args) throws Exception {
		
		List<String> puzzleLines = Files.readAllLines(Paths.get("woftracker", "log", "all_puzzle_cats.txt"), Charset.defaultCharset());
		Map<LocalDate, LinkedList<String>> puzzleMap = new HashMap<>();
		LocalDate currentDate = null;
		for(String line : puzzleLines)
			if(line.startsWith("\t"))
				puzzleMap.get(currentDate).add(line.substring(1));
			else {
				currentDate = LocalDate.parse(line, DateTimeFormatter.ofPattern("uu/MM/dd"));
				puzzleMap.put(currentDate, new LinkedList<>());
			}
		
		if(args.length == 0) {
			try(FileWriter fW = new FileWriter(new File("analysis\\temp\\gA main testing.txt"))) {				
				TreeSet<GameAnalysis> gAs = new TreeSet<>();
				System.out.println("Now loading...");
				Arrays.stream(new File("analysis").listFiles()).filter(ff -> ff.isDirectory() && ff.getName().matches("s\\d{2}"))
					.forEach(ff -> Arrays.stream(ff.listFiles()).filter(f -> !f.isDirectory())
						.forEach(f -> { try { gAs.add(GameAnalysis.readAnalysis(f)); } catch(Exception ex) { System.out.println(f); ex.printStackTrace();} })
					);
				
				System.out.println("Done loading " + gAs.size() + " analyses. now processing...");
				Category.setPlural(true);
				//reference: 5702 is the first show to use convertReadoutToAnalysis.
				gAs.stream()
					//condition for shows to change/look to
					.filter(gA -> true)
					.forEachOrdered(gA -> {	//now either inspect or do something about it
						try {
							//BR W/L lines
							/*if(gA.showNumber % 5 == 1)
								System.out.print(String.format("%02d", gA.seasonNumber/5 + 1) + ": ");
							System.out.print(gA.roundWinners.get(Round.BR) == null ? 'L' : 'W');
							if(gA.showNumber % 5 == 0)
								System.out.println();*/
							
							/*LinkedList<String> puzzles = puzzleMap.get(gA.showDate);
							
							if(puzzles == null) {
								System.err.println("Categories not found for " + gA.getShowInfo());
								return;
							}
							
							if(puzzles.size() != gA.roundCat.size())
								System.err.println("Categories size mismatch for " + gA.getShowInfo() + ": " + puzzles.size() + " vs. " + gA.roundCat.size());
							else {
								gA.catPlurality = 0;
								Iterator<Map.Entry<Round, Category>> i = gA.roundCat.entrySet().iterator();
								for(String s : puzzles) {
									Map.Entry<Round, Category> catEntry = i.next();
									Round r = catEntry.getKey(); Category rc = catEntry.getValue();
									
									boolean plural = false;
									Category c = Category.LOOKUP.get(s);
									if(c == null) {
										c = Category.PLURAL_LOOKUP.get(s);
										if(c != null)
											plural = true;
										else {
											System.err.println("Illegal category for " + gA.getShowInfo() + ": " + s);
											return;
										}
									}
									
									if(c != rc) {
										if((gA.getShowNumber() == 5509 && r == Round.T1) || (gA.getShowNumber() == 5520 && r == Round.BR) || (gA.getShowNumber() == 5525 && r == Round.T2) || (gA.getShowNumber() == 5597 && r == Round.BR) || (gA.getShowNumber() == 5686 && r == Round.T1) || (gA.getShowNumber() == 5787 && r == Round.BR) || (gA.getShowNumber() == 5850 && r == Round.BR) || (gA.getShowNumber() == 5886 && r == Round.T2) || (gA.getShowNumber() == 6058 && r == Round.R3) || (gA.getShowNumber() == 6154 && r == Round.R5)) {
											gA.roundCat.put(r, c);
										} else {
											System.err.println("Category mismatch for " + gA.getShowInfo() + " at " + r + ": " + rc + " vs. " + c);
											return;
										}
									}
									
									if(plural)
										gA.catPlurality |= 1 << r.ordinal();
								}
							}
							*/
							
							if(false) {	//use cautiously!
								gA.synthesizeGame(true);
								gA.writeAnalysis(true);
							} else {
								gA.writeReport();
							}
							
						} catch (IOException e) {
							e.printStackTrace();
						}
					});
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			/* //rename ser to wga
			TreeSet<GameAnalysis> gAs = new TreeSet<>();
				Arrays.stream(new File("analysis").listFiles()).filter(ff -> ff.isDirectory() && ff.getName().matches("s\\d{2}"))
					.forEach(ff -> Arrays.stream(ff.listFiles()).filter(f -> !f.isDirectory())
						.forEach(f -> { try { 
							if(!f.renameTo(new File(ff, f.getName().replace("ser", "wga"))))
								throw new RuntimeException(f + " failed");
							} catch(Exception ex) {ex.printStackTrace();} })
					);
			*/
		}
	}
}